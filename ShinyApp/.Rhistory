?cbind
shiny::runApp('~/Seneca/Dan/alignment')
rbind(c(0,seqB),trace)
seqB
seqA
seqA <- strsplit(seqA,c())[[1]]
seqB <- strsplit(seqB,c())[[1]]
rbind(c(0,seqB),trace)
cbind(c(0,seqA),trace)
trace <- rbind(c(0,seqB),trace)
trace <- cbind(c(0,seqA),trace)
trace <- rbind(c(0,seqB),trace)
trace
NW <- function(seqA,seqB,gapPen,id_matrix){
seqA <- strsplit(seqA,c())[[1]]
seqB <- strsplit(seqB,c())[[1]]
# Creates empty matrices
start <- create(seqA,seqB,gapPen)
score <- start[[1]]
trace <- start[[2]]
for (i in seq(2,length(seqA)+1,by=1)){
for (j in seq(2,length(seqB)+1,by=1)){
# Finds the match score
posA <- seqA[i-1]
posB <- seqB[j-1]
posA <- match(posA,dna)
posB <- match(posB,dna)
matchVal <- id_matrix[posA,][posB]
# Determines the top score
topleft <- score[(i-1),][j-1] + matchVal
top <- score[(i-1),][j] + gapPen
left <- score[i,][j-1] + gapPen
# insert values into matrices
score[i,][j] <- max(top,left,topleft)
trace[i,][j] <- traceFun(top,left,topleft)
}
}
score <- data.frame(score)
trace <- data.frame(trace)
#         score <- rbind(c(0,seqB),score)
#         score <- cbind(c(0,seqA),score)
#
#         trace <- rbind(c(0,seqB),trace)
#         trace <- cbind(c(0,seqA),trace)
#
#
return(list(score,trace))
}
NW("AGC","AGC",-1,id_matrix)
score
trace
NW("AGC","AGC",-1,id_matrix)
NW("AGC","AGC",-1,id_matrix)[[1]]
class(NW("AGC","AGC",-1,id_matrix)[[1]])
seqA <- strsplit(seqA,c())[[1]]
seqB <- strsplit(seqB,c())[[1]]
# Creates empty matrices
start <- create(seqA,seqB,gapPen)
score <- start[[1]]
trace <- start[[2]]
for (i in seq(2,length(seqA)+1,by=1)){
for (j in seq(2,length(seqB)+1,by=1)){
# Finds the match score
posA <- seqA[i-1]
posB <- seqB[j-1]
posA <- match(posA,dna)
posB <- match(posB,dna)
matchVal <- id_matrix[posA,][posB]
# Determines the top score
topleft <- score[(i-1),][j-1] + matchVal
top <- score[(i-1),][j] + gapPen
left <- score[i,][j-1] + gapPen
# insert values into matrices
score[i,][j] <- max(top,left,topleft)
trace[i,][j] <- traceFun(top,left,topleft)
}
}
score <- data.frame(score)
trace <- data.frame(trace)
score
tracce
trace
rbind(c(0,seqB),score)
score <- rbind(c(0,seqB),score)
score <- cbind(c("Sequence",0,seqA),score)
score
trace <- rbind(c(0,seqB),trace)
trace <- cbind(c("Sequence",0,seqA),trace)
trace
shiny::runApp('~/Seneca/Dan/alignment')
shiny::runApp('~/Seneca/Dan/alignment')
shiny::runApp('~/Seneca/Dan/alignment')
shiny::runApp('~/Seneca/Dan/alignment')
shiny::runApp('~/Seneca/Dan/alignment')
shiny::runApp('~/Seneca/Dan/alignment')
shiny::runApp('~/Seneca/Dan/alignment')
x1=c(1:5)
y1=c(1:5)
round1 <- c(1,2,1,3,4)
df <- data.frame(x1,y1,round1)
df
plot(x=df$x1,y=df$y1)
text(df$x1, df$y1, labels=format(round(df$y1,df$round1)) , cex= 0.7, pos=3)
?round
round(round1,digits=1)
round(round1,digits=2)
round(1,digits=2)
signif(round1,digits=2)
signif(1,digits=3)
signif(1,digits=6)
signif(1.23,digits=6)
x1=c(1:5)
y1=c(1:5)
round1 <- c(1,2,1,3,4)
df <- data.frame(x1,y1,round1)
df
plot(x=df$x1,y=df$y1)
text(df$x1, df$y1, labels=format(round(df$y1,df$round1)) , cex= 0.7, pos=3)
round(1.313213,digits=3)
options(digits=2)
x1=c(1:5)
y1=c(1:5)
round1 <- c(1,2,1,3,4)
df <- data.frame(x1,y1,round1)
df
plot(x=df$x1,y=df$y1)
text(df$x1, df$y1, labels=format(round(df$y1,df$round1)) , cex= 0.7, pos=3)
?options
signif(round1,digits=2)
format(round(round1, 2), nsmall = 2)
## Assign how many digits you want to digits:
digits=3
format(round(round1,digits),nsmall=digits)
df <- data.frame(x1,y1,round1)
df
plot(x=df$x1,y=df$y1)
text(df$x1, df$y1, labels=format(round(df$y1,df$round1)) , cex= 0.7, pos=3)
round1 <- format(round(round1,digits),nsmall=digits)
df <- data.frame(x1,y1,round1)
df
plot(x=df$x1,y=df$y1)
text(df$x1, df$y1, labels=format(round(df$y1,df$round1)) , cex= 0.7, pos=3)
plot(x=df$x1,y=df$y1)
text(df$x1, df$y1, labels=round1 , cex= 0.7, pos=3)
?format
source('http://depot.sagebase.org/CRAN.R')
pkgInstall(c("synapseClient"))
shiny::runApp('~/Seneca/Dan/alignment')
shiny::runApp('~/Seneca/Dan/alignment')
max(2,2)
?r.bind
?rbind
traceBackNW <- function(seqA,seqB,listMat){
# Splits the sequences
seqA <- strsplit(toupper(seqA),c())[[1]]
seqB <- strsplit(toupper(seqB),c())[[1]]
## Pulls in the matrices
matchMat <- listMat[[1]]
gap1 <- listMat[[2]]
gap2 <- listMat[[3]]
## Creates empty vectors for aligned sequences
alignedA <- c()
alignedB <- c()
matchLine <- c()
# figures out the dimensions of the matrix
i <- dim(matchMat)[1]
j <- dim(matchMat)[2]
# Until it goes to the top.
while(i != 1 & j != 1){
# Figures out the which of the matrices produces the max (This alignment favours matches over gap)
maxVal <- max(matchMat[i,][j],gap1[i,][j],gap2[i,][j])
boolTrace <- maxVal == list(matchMat[i,][j],gap1[i,][j],gap2[i,][j])
chooseTrace <- match(TRUE,boolTrace)
# chooseTrace has 1=match, 2=gap in sequence 1, 3=gap in sequence 2
if(chooseTrace == 1){
alignedA = c(seqA[i-1],alignedA)
alignedB = c(seqB[j-1],alignedB)
# Handles the case of the line between the two sequences
if(seqA[i-1]==seqB[j-1]){
matchLine = c("|",matchLine)
}
else{
matchLine = c(" ",matchLine)
}
i = i - 1
j = j - 1
}
else if(chooseTrace == 2){
alignedA = c(seqA[i-1],alignedA)
alignedB = c("-",alignedB)
matchLine = c(" ",matchLine)
i = i - 1
}
else if(chooseTrace == 3){
alignedA = c("-",alignedA)
alignedB = c(seqB[j-1],alignedB)
matchLine = c(" ",matchLine)
j = j - 1
}
}
## Deals with the remaining gaps once it hits the end of a sequence.
if(i==1){
while(j != 1){
alignedA = c("-",alignedA)
alignedB = c(seqB[j-1],alignedB)
matchLine = c(" ",matchLine)
j = j - 1
}
}
if(j==1){
while(i !=1){
alignedA = c(seqA[i-1],alignedA)
alignedB = c("-",alignedB)
matchLine = c(" ",matchLine)
i = i - 1
}
}
return(list(alignedA,alignedB,matchLine))
}
NW <- function(seqA,seqB,gapPen,gapStart,matrix){
seqA <- strsplit(toupper(seqA),c())[[1]]
seqB <- strsplit(toupper(seqB),c())[[1]]
# Creates empty matrices
start <- create(seqA,seqB,gapPen,gapStart)
matchMat <- start[[1]]
gap1 <- start[[2]]
gap2 <- start[[3]]
# Creates reference sequence from scoring matrix
ref <- names(matrix)
for (i in seq(2,length(seqA)+1,by=1)){
for (j in seq(2,length(seqB)+1,by=1)){
# Finds the match score
posA <- seqA[i-1]
posB <- seqB[j-1]
posA <- match(posA,ref)
posB <- match(posB,ref)
matchVal <- as.numeric(matrix[posA,][posB])
# Assigns value to each one.
matchMat[i,][j] <- matchVal + max(matchMat[(i-1),][(j-1)],
gap1[(i-1),][(j-1)],
gap2[(i-1),][(j-1)])
gap1[i,][j] <- max(matchMat[i,][(j-1)] + gapStart + gapPen,
gap1[i,][(j-1)] + gapPen,
gap2[i,][(j-1)], + gapStart + gapPen)
gap2[i,][j] <- max(matchMat[(i-1),][j] + gapStart + gapPen,
gap1[(i-1),][j] + gapStart + gapPen,
gap2[(i-1),][j] + gapPen)
}
}
return(list(matchMat,gap1,gap2))
}
## Function to create empty trace and score matrices
create <- function(seqA,seqB,gapPen,gapStart){
# Match matrix, gap1 represents gap in seqA, gap2 represents gap in seqB
matchMat <- matrix(data=NA,nrow=length(seqA)+1,ncol = length(seqB)+1)
gap1 <- matrix(data=NA,nrow=length(seqA)+1,ncol = length(seqB)+1)
gap2 <- matrix(data=NA,nrow=length(seqA)+1,ncol = length(seqB)+1)
matchMat[,1][1] <- 0
gap1[,1][1] <- 0 + gapStart
gap2[,1][1] <- 0 + gapStart
for(i in seq(2,length(seqA)+1,by=1)){
matchMat[i,][1] <- matchMat[(i-1),][1] + gapPen
gap1[i,][1] <- gap1[(i-1),][1] + gapPen
gap2[i,][1] <- gap2[(i-1),][1] + gapPen
}
for (j in seq(2,length(seqB)+1,by=1)){
matchMat[1,][j] <- matchMat[1,][j-1] +gapPen
gap1[1,][j] <- gap1[1,][j-1] +gapPen
gap2[1,][j] <- gap2[1,][j-1] +gapPen
}
return(list(matchMat,gap1,gap2))
}
seqA <- "GCA"
seqB <- "GCT"
matrix <- read.table("ID.txt")
getwd()
setwd("C:/Users/Nishanth/Documents/Perl/alignment")
setwd("C:/Users/Nishanth/Documents/Perl/alignment/shinyApp")
matrix <- read.table("ID.txt")
matrix
NW(seqA,seqB,-1,0,matrix)
traceInput <- NW(seqA,seqB,-1,0,matrix)
traceBackNW(traceInput)
seqA
traceBackNW(seqA,seqB,traceInput)
seqA <- "AGCCCAGA"
NW(seqA,seqB,-1,0,matrix)
traceInput <- NW(seqA,seqB,-1,0,matrix)
traceBackNW(seqA,seqB,traceInput)
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
traceBackNW <- function(seqA,seqB,listMat){
# Splits the sequences
seqA <- strsplit(toupper(seqA),c())[[1]]
seqB <- strsplit(toupper(seqB),c())[[1]]
## Pulls in the matrices
matchMat <- listMat[[1]]
gap1 <- listMat[[2]]
gap2 <- listMat[[3]]
## Creates empty vectors for aligned sequences
alignedA <- c()
alignedB <- c()
matchLine <- c()
# figures out the dimensions of the matrix
i <- dim(matchMat)[1]
j <- dim(matchMat)[2]
# Until it goes to the top.
while(i != 1 & j != 1){
# Figures out the which of the matrices produces the max (This alignment favours matches over gap)
maxVal <- max(matchMat[i,][j],gap1[i,][j],gap2[i,][j])
boolTrace <- maxVal == list(matchMat[i,][j],gap1[i,][j],gap2[i,][j])
chooseTrace <- match(TRUE,boolTrace)
# chooseTrace has 1=match, 2=gap in sequence 1, 3=gap in sequence 2
if(chooseTrace == 1){
alignedA = c(seqA[i-1],alignedA)
alignedB = c(seqB[j-1],alignedB)
# Handles the case of the line between the two sequences
if(seqA[i-1]==seqB[j-1]){
matchLine = c("|",matchLine)
}
else{
matchLine = c(" ",matchLine)
}
i = i - 1
j = j - 1
}
else if(chooseTrace == 2){
alignedA = c(seqA[i-1],alignedA)
alignedB = c("-",alignedB)
matchLine = c(" ",matchLine)
i = i - 1
}
else if(chooseTrace == 3){
alignedA = c("-",alignedA)
alignedB = c(seqB[j-1],alignedB)
matchLine = c(" ",matchLine)
j = j - 1
}
}
## Deals with the remaining gaps once it hits the end of a sequence.
if(i==1){
while(j != 1){
alignedA = c("-",alignedA)
alignedB = c(seqB[j-1],alignedB)
matchLine = c(" ",matchLine)
j = j - 1
}
}
if(j==1){
while(i !=1){
alignedA = c(seqA[i-1],alignedA)
alignedB = c("-",alignedB)
matchLine = c(" ",matchLine)
i = i - 1
}
}
return(list(alignedA,alignedB,matchLine))
}
fillMat <- function(seqA,seqB,gapPen,gapStart,matrix){
seqA <- strsplit(toupper(seqA),c())[[1]]
seqB <- strsplit(toupper(seqB),c())[[1]]
# Creates empty matrices
start <- create(seqA,seqB,gapPen,gapStart)
matchMat <- start[[1]]
gap1 <- start[[2]]
gap2 <- start[[3]]
# Creates reference sequence from scoring matrix
ref <- names(matrix)
for (i in seq(2,length(seqA)+1,by=1)){
for (j in seq(2,length(seqB)+1,by=1)){
# Finds the match score
posA <- seqA[i-1]
posB <- seqB[j-1]
posA <- match(posA,ref)
posB <- match(posB,ref)
matchVal <- as.numeric(matrix[posA,][posB])
# Assigns value to each one.
matchMat[i,][j] <- matchVal + max(matchMat[(i-1),][(j-1)],
gap1[(i-1),][(j-1)],
gap2[(i-1),][(j-1)])
gap1[i,][j] <- max(matchMat[i,][(j-1)] + gapStart + gapPen,
gap1[i,][(j-1)] + gapPen,
gap2[i,][(j-1)], + gapStart + gapPen)
gap2[i,][j] <- max(matchMat[(i-1),][j] + gapStart + gapPen,
gap1[(i-1),][j] + gapStart + gapPen,
gap2[(i-1),][j] + gapPen)
}
}
return(list(matchMat,gap1,gap2))
}
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
source("fillMat.R",local=T)
source("tracebackNW.R",local=T)
source("create.R",local=T)
source("fillMat.R",local=T)
seqAOut <- eventReactive(input$button,{traceBackNW(input$seqA,input$seqB,
fillMat(input$seqA,input$seqB,input$slider1,input$slider2,read.table(input$scoring_matrix)))[[1]]})
seqAOut
eventReactive(input$button,{traceBackNW(input$seqA,input$seqB,
fillMat(input$seqA,input$seqB,input$slider1,input$slider2,read.table(input$scoring_matrix)))[[1]]})
fillMat(input$seqA,input$seqB,input$slider1,input$slider2,read.table(input$scoring_matrix)))[[1]]
traceBackNW(input$seqA,input$seqB,
fillMat(input$seqA,input$seqB,input$slider1,input$slider2,read.table(input$scoring_matrix)))
input$seqA <- "A"
input<- list()
input$seqA <- "A"
input$seqB <- "A"
input$slider1 <- -1
input$slider1 <- -1
input$slider2 <- -1
input$scoring_matrix <- "ID.txt"
traceBackNW(input$seqA,input$seqB,
fillMat(input$seqA,input$seqB,input$slider1,input$slider2,read.table(input$scoring_matrix)))[[1]]
traceBackNW(input$seqA,input$seqB,
fillMat(input$seqA,input$seqB,input$slider1,input$slider2,read.table(input$scoring_matrix)))
eventReactive(input$button,{traceBackNW(input$seqA,input$seqB,
fillMat(input$seqA,input$seqB,input$slider1,input$slider2,read.table(input$scoring_matrix)))[[1]]})
seqAOut <- eventReactive(input$button,{traceBackNW(input$seqA,input$seqB,
fillMat(input$seqA,input$seqB,input$slider1,input$slider2,read.table(input$scoring_matrix
seqAOut <- eventReactive(input$button,{traceBackNW(input$seqA,input$seqB,
fillMat(input$seqA,input$seqB,input$slider1,input$slider2,read.table(input$scoring_matrix)))[[1]]})
seqAOut <- eventReactive(input$button,{traceBackNW(input$seqA,input$seqB,
fillMat(input$seqA,input$seqB,input$slider1,input$slider2,read.table(input$scoring_matrix)))[[1]]})
seqAOut
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
?renderPrint
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
?renderPrint
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
?HTML
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
?paste
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
?cat
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
?as.name
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
?cat
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
shiny::runApp('~/Perl/alignment/ShinyApp')
