shiny::runApp()
shiny::runApp('~/Seneca/Dan/alignment')
shiny::runApp('~/Seneca/Dan/alignment')
NW <- function(seqA,seqB,gapPen,id_matrix){
seqA <- strsplit(toupper(seqA),c())[[1]]
seqB <- strsplit(toupper(seqB),c())[[1]]
# Creates empty matrices
start <- create(seqA,seqB,gapPen)
score <- start[[1]]
trace <- start[[2]]
for (i in seq(2,length(seqA)+1,by=1)){
for (j in seq(2,length(seqB)+1,by=1)){
# Finds the match score
posA <- seqA[i-1]
posB <- seqB[j-1]
posA <- match(posA,dna)
posB <- match(posB,dna)
matchVal <- id_matrix[posA,][posB]
# Determines the top score
topleft <- score[(i-1),][j-1] + matchVal
top <- score[(i-1),][j] + gapPen
left <- score[i,][j-1] + gapPen
# insert values into matrices
score[i,][j] <- max(top,left,topleft)
trace[i,][j] <- traceFun(top,left,topleft)
}
}
score <- data.frame(score)
trace <- data.frame(trace)
score <- rbind(c(0,seqB),score)
score <- cbind(c("Sequence",0,seqA),score)
trace <- rbind(c(0,seqB),trace)
trace <- cbind(c("Sequence",0,seqA),trace)
return(list(score,trace))
}
getwd()
read.table("BLOSUM.txt")
read.table("BLOSUM.txt")[1]
read.table("BLOSUM.txt")[,1]
read.table("BLOSUM.txt")[1,]
read.table("BLOSUM.txt")[3,]
read.table("BLOSUM.txt")["N",]
read.table("BLOSUM.txt")
Abp <- c(1,0,0,0)
Cbp <- c(0,1,0,0)
Tbp <- c(0,0,1,0)
Gbp <- c(0,0,0,1)
dna <- c("A","C","T","G")
dim <- list(x=dna,y=dna)
id_matrix <- matrix(data=c(Abp,Cbp,Tbp,Gbp),nrow=4,ncol=4,dimnames=dim)
id_matrix
read.table("BLOSUM.txt")
getwd()
read.table("BLOSUM.txt")
scoring_matrix <- read.table("BLOSUM.txt")
read.table("TSTV.txt")
scoring_matrix <- read.table("TSTV.txt")
NW("ATG","GTA",-1,scoring_matrix)
traceFun <- function(top, left, topleft){
## Function that returns the traceback direction in the trace matrix
## Inputs are vectors of 3 (NW) or 4 (SW)
# 1=left
if(left > top & left > topleft){
return(1)
}
# 2=top
else if(top > left & top > topleft){
return(2)
}
# 3=top and left
else if(top == left & top > topleft){
return(3)
}
# 4=topleft
else if(topleft > left & topleft > top){
return(4)
}
# 5=topleft and left
else if(topleft == left & topleft > top){
return(5)
}
# 6=topleft and top
else if(topleft > left & topleft == top){
return(6)
}
# 7=topleft, left and top
else if(topleft == left & topleft == top){
return(7)
}
}
NW <- function(seqA,seqB,gapPen,id_matrix){
seqA <- strsplit(toupper(seqA),c())[[1]]
seqB <- strsplit(toupper(seqB),c())[[1]]
# Creates empty matrices
start <- create(seqA,seqB,gapPen)
score <- start[[1]]
trace <- start[[2]]
for (i in seq(2,length(seqA)+1,by=1)){
for (j in seq(2,length(seqB)+1,by=1)){
# Finds the match score
posA <- seqA[i-1]
posB <- seqB[j-1]
posA <- match(posA,dna)
posB <- match(posB,dna)
matchVal <- id_matrix[posA,][posB]
# Determines the top score
topleft <- score[(i-1),][j-1] + matchVal
top <- score[(i-1),][j] + gapPen
left <- score[i,][j-1] + gapPen
# insert values into matrices
score[i,][j] <- max(top,left,topleft)
trace[i,][j] <- traceFun(top,left,topleft)
}
}
score <- data.frame(score)
trace <- data.frame(trace)
score <- rbind(c(0,seqB),score)
score <- cbind(c("Sequence",0,seqA),score)
trace <- rbind(c(0,seqB),trace)
trace <- cbind(c("Sequence",0,seqA),trace)
return(list(score,trace))
}
## Function to create empty trace and score matrices
create <- function(seqA,seqB,gapPen){
score <- matrix(data=NA,nrow=length(seqA)+1,ncol = length(seqB)+1)
trace <- matrix(data=NA,nrow=length(seqA)+1,ncol = length(seqB)+1)
score[,1][1] <- 0
trace[,1][1] <- 0
for(i in seq(2,length(seqA)+1,by=1)){
score[i,][1] <- score[(i-1),][1] + gapPen
trace[i,][1] <- 2
}
for (j in seq(2,length(seqB)+1,by=1)){
score[1,][j] <- score[1,][j-1] +gapPen
trace[1,][j] <- 1
}
return(list(score,trace))
}
NW("ATG","GTA",-1,scoring_matrix)
NW("ATG","GTA",-1,scoring_matrix)
seqA <- strsplit(toupper(seqA),c())[[1]]
seqB <- strsplit(toupper(seqB),c())[[1]]
seqA = "AGT"
seqB = "AGA"
seqA <- strsplit(toupper(seqA),c())[[1]]
seqB <- strsplit(toupper(seqB),c())[[1]]
start <- create(seqA,seqB,gapPen)
score <- start[[1]]
trace <- start[[2]]
gapPen = -1
start <- create(seqA,seqB,gapPen)
score <- start[[1]]
trace <- start[[2]]
for (i in seq(2,length(seqA)+1,by=1)){
for (j in seq(2,length(seqB)+1,by=1)){
# Finds the match score
posA <- seqA[i-1]
posB <- seqB[j-1]
posA <- match(posA,dna)
posB <- match(posB,dna)
matchVal <- id_matrix[posA,][posB]
# Determines the top score
topleft <- score[(i-1),][j-1] + matchVal
top <- score[(i-1),][j] + gapPen
left <- score[i,][j-1] + gapPen
# insert values into matrices
score[i,][j] <- max(top,left,topleft)
trace[i,][j] <- traceFun(top,left,topleft)
}
}
score <- data.frame(score)
trace <- data.frame(trace)
score <- rbind(c(0,seqB),score)
score <- cbind(c("Sequence",0,seqA),score)
trace <- rbind(c(0,seqB),trace)
trace <- cbind(c("Sequence",0,seqA),trace)
score
trace
NW("AGT","AGA",-1,scoring_matrix)
NW <- function(seqA,seqB,gapPen,id_matrix){
seqA <- strsplit(toupper(seqA),c())[[1]]
seqB <- strsplit(toupper(seqB),c())[[1]]
# Creates empty matrices
start <- create(seqA,seqB,gapPen)
score <- start[[1]]
trace <- start[[2]]
for (i in seq(2,length(seqA)+1,by=1)){
for (j in seq(2,length(seqB)+1,by=1)){
# Finds the match score
posA <- seqA[i-1]
posB <- seqB[j-1]
posA <- match(posA,dna)
posB <- match(posB,dna)
matchVal <- id_matrix[posA,][posB]
# Determines the top score
topleft <- score[(i-1),][j-1] + matchVal
top <- score[(i-1),][j] + gapPen
left <- score[i,][j-1] + gapPen
# insert values into matrices
score[i,][j] <- max(top,left,topleft)
trace[i,][j] <- traceFun(top,left,topleft)
}
}
score <- data.frame(score)
trace <- data.frame(trace)
score <- rbind(c(0,seqB),score)
score <- cbind(c("Sequence",0,seqA),score)
trace <- rbind(c(0,seqB),trace)
trace <- cbind(c("Sequence",0,seqA),trace)
return(list(score,trace))
}
NW("AGT","AGA",-1,scoring_matrix)
shiny::runApp()
seqA= "ATG"
seqB="GAT"
seqA <- strsplit(toupper(seqA),c())[[1]]
seqB <- strsplit(toupper(seqB),c())[[1]]
seqA
seqB
create(seqA,seqB,gapPen)
start <- create(seqA,seqB,gapPen)
score <- start[[1]]
trace <- start[[2]]
i=2
j=2
posA <- seqA[i-1]
scoring_matrix
scoring_matrix[1,]
names(scoring_matrix)
shiny::runApp()
shiny::runApp()
names(scoring_matrix)
posA <- seqA[i-1]
posB <- seqB[j-1]
posA
posB
posA <- match(posA,ref)
posB <- match(posB,ref)
ref <- names(id_matrix)
posA <- match(posA,ref)
posB <- match(posB,ref)
posA
posB
match("a")
match("A",ref)
ref
ref = names(scoring_matrix)
match("A",ref)
match("C",ref)
match("G",ref)
match("T",ref)
posA <- seqA[i-1]
posB <- seqB[j-1]
posA <- match(posA,ref)
posB <- match(posB,ref)
id_matrix <- scoring_matrix
matchVal <- id_matrix[posA,][posB]
topleft <- score[(i-1),][j-1] + matchVal
top <- score[(i-1),][j] + gapPen
left <- score[i,][j-1] + gapPen
topleft
left
top
class(topleft)
matchVal
score[(i-1),][j-1]
topleft
max(top,left,topleft)
topleft
as.integer(topleft)
?as.integer
as.integer(top,left,topleft)
topleft <- as.integer(score[(i-1),][j-1] + matchVal)
top <- score[(i-1),][j] + gapPen
left <- score[i,][j-1] + gapPen
max(top,left,topleft)
traceFun(top,left,topleft)
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
?eventReactive
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
